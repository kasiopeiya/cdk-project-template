# テスト仕様書

## 1. 概要

## 2. 単体テストの方針

### 2.1 基本思想

本プロジェクトの単体テストは以下の3つの思想を基盤とする。

#### コードは資産ではなく負債である

コードが増えればバグが持ち込まれる経路が増え、保守コストが高くなる。テストコードも例外ではなく保守対象である。したがって、**明確な価値をもたらさないテストは作成しない**。質の悪いテストを書くくらいなら、書かないほうがマシである。

#### 古典学派（Classical School）スタイルの採用

- 隔離対象は**コードではなくテストケース**。各テストケースが互いに影響を与えず独立して実行できることを重視する
- テストダブルの使用は**共有依存（テストケース間で共有される状態）のみ**に限定する
- 「単体」は1つのクラスに限定せず、**同じ振る舞いを達成するクラスのグループ**も含む

#### 価値あるテストだけを実装する

- コードベースの**特に重要な部分（ビジネスロジック）のみ**をテスト対象とする
- 最小限のコストで最大限の価値を生み出すテストスイートを目指す
- テストスイートの質を測る唯一の方法は、各テストケースを1つずつ評価することである

### 2.2 テスト対象の定義

| レイヤー | テスト対象の「単体」 | 備考 |
| --- | --- | --- |
| バックエンド | Lambda関数のhandler | handlerを起点に振る舞いを検証 |
| フロントエンド | コンポーネント / カスタムフック | ユーザー操作に対する振る舞いを検証 |

### 2.3 検証原則

#### 振る舞いを検証し、実装の詳細を検証しない

テストは**観察可能な振る舞い（出力・戻り値・状態変化）**のみを検証する。内部の実装詳細（privateメソッドの呼び出し順序、内部変数の中間状態など）を検証してはならない。

<details>
<summary>なぜ実装の詳細を検証してはならないのか</summary>

実装の詳細を検証すると、振る舞いを変えないリファクタリング（メソッド名の変更、内部処理の再構成など）でテストが壊れるようになる。これは**偽陽性**（コードは正しく動いているのにテストが失敗する状態）を引き起こす。偽陽性が多いテストスイートは開発者の信頼を失い、テスト失敗が日常的に無視されるようになる（**オオカミ少年問題**）。結果としてテストスイートの存在意義が失われ、本物のバグを見逃す原因になる。
</details>

```typescript
// ✅ 良い例：観察可能な振る舞い（出力）を検証
// → 内部でどのような関数を使っていても、このテストは壊れない
const result = await handler(event, context)
expect(result.statusCode).toBe(200)
expect(JSON.parse(result.body).userId).toBe('user-123')

// ❌ 悪い例：実装の詳細（内部メソッドの呼び出し過程）を検証
// → formatName を rename しただけでテストが壊れる（偽陽性）
expect(formatNameSpy).toHaveBeenCalledWith('alice')
expect(validateInputSpy).toHaveBeenCalledTimes(1)
```

#### ブラックボックステストで書く

テスト対象の内部構造を意識せず、入力と出力のみに着目する。これにより**リファクタリングへの耐性**が確保される。

<details>
<summary>なぜブラックボックステストを採用するのか</summary>

ホワイトボックステスト（内部構造を意識したテスト）は退行（バグ）への保護には優れるが、内部実装の変更に対して脆い。一方、ブラックボックステストはリファクタリングへの耐性に優れる。単体テストにおいてリファクタリングへの耐性は最も優先すべき特性であるため、ブラックボックステストを採用する。ホワイトボックス的な分析（カバレッジ計測等）はテスト設計の参考情報として活用し、テストの実装そのものはブラックボックスで行う。
</details>

#### 検証手法の優先順位

| 優先度 | 手法 | 検証内容 | 使用場面 |
| --- | --- | --- | --- |
| 1 | 出力値ベース | 戻り値の確認 | 副作用のない処理 |
| 2 | 状態ベース | 処理後の状態確認 | 状態を変化させる処理 |
| 3 | コミュニケーションベース | 依存への呼び出し確認 | 単体テストでは原則不使用 |

### 2.4 テストダブルの使用方針

#### 基本方針：単体テストではモック・スタブを可能な限り使用しない

<details>
<summary>なぜテストダブルの使用を避けるのか</summary>

テストダブルを多用すると、テストが実装の詳細（どのメソッドがどの引数で呼ばれたか）に依存しやすくなり、リファクタリングへの耐性が低下する。また、テストダブルで置き換えた部分は実際のコードが動いていないため、退行（バグ）を検出する能力も下がる。古典学派の原則に基づき、ビジネスロジック（ドメイン）とプロセス外依存の連携（コントローラ）が分離されていれば、単体テストの対象であるドメインは外部依存を持たないはずであり、テストダブルは不要になる。
</details>

| 依存の種別 | テストダブル使用 | 具体例 |
| --- | --- | --- |
| 共有依存 | ✅ 使用する | DB、ファイルシステム、外部API |
| プライベート依存（可変） | ❌ 使用しない | 内部で利用するクラス・関数 |
| プライベート依存（不変） | ❌ 使用しない | 値オブジェクト、定数 |

#### スタブとのやりとりを検証してはならない

スタブは最終的な結果を生成するために必要なデータを提供するだけのものである。

<details>
<summary>なぜスタブとのやりとりを検証してはならないのか</summary>

スタブの呼び出し過程（どの引数で呼ばれたか、何回呼ばれたか）を検証することは**過剰検証（over specification）**にあたる。これはテストを実装の詳細に結びつけることになり、内部のリファクタリングでテストが壊れる原因になる。検証すべきはスタブから得たデータを使って生成される**最終的な結果のみ**である。
</details>

```typescript
// ✅ 良い例：スタブはデータ提供のみ、検証は最終結果に対して行う
const stubRepository = { findById: () => ({ id: 'user-123', name: 'Alice' }) }
const result = await handler(event, context)
expect(result.statusCode).toBe(200)

// ❌ 悪い例：スタブとのやりとりの過程を検証している
expect(stubRepository.findById).toHaveBeenCalledWith('user-123')
```

#### モックの使用は統合テストのみ

管理下にない外部プロセス依存（外部API等）とのコミュニケーション検証にはモックを使用するが、それは統合テストの責務とする。

<details>
<summary>なぜモックの使用を統合テストに限定するのか</summary>

モックはテストダブルの中で唯一「正しく呼び出されたかを検証する」機能を持つ。この検証が正当化されるのは、外部システムとの通信（メール送信、外部API呼び出し等）のように、呼び出しの有無そのものがアプリケーションの観察可能な振る舞いである場合のみである。単体テストの対象であるドメインロジックにはそのような外部通信は含まれないため、モックを使う場面は存在しない。
</details>

### 2.5 テストコードの書き方

#### AAAパターン（Arrange-Act-Assert）

すべてのテストケースを3つのフェーズで構成する。

| フェーズ | 役割 | ルール |
| --- | --- | --- |
| Arrange（準備） | テストに必要なオブジェクト・データを用意 | 長すぎる場合はプロダクションコードの設計を見直すシグナル |
| Act（実行） | テスト対象の処理を実行 | **必ず1行**。複数行になる場合はカプセル化の失敗を示す |
| Assert（確認） | 結果を検証 | 1単位の振る舞いの結果が複数になることはあるため、複数assertは許容 |

<details>
<summary>各フェーズのルールの理由</summary>

- **準備が長すぎる場合：** テスト対象が多くの依存を必要としていることを意味し、クラスや関数の責務が大きすぎる可能性がある。テストダブルで隠すのではなく、プロダクションコードの設計を改善すべきシグナルとして扱う
- **実行が1行でない場合：** 1つの目標を達成するために複数の操作が必要になっているということは、公開APIのカプセル化が不十分であることを意味する。1回の呼び出しで目標を達成できるようにAPIを設計すべきである
- **確認が複数行の場合：** 古典学派では1単位の振る舞いを検証するため、その結果が複数の値に現れることは自然である。ただし、あまりにassertが多い場合はテストの焦点がぼやけていないか見直す
</details>

**フェーズコメントの記載ルール：**

- 準備フェーズまたは確認フェーズのコードが複数行にわたる（空白行での区切りが必要な）場合 → 各フェーズの先頭に `// Arrange` `// Act` `// Assert` コメントを入れる
- それ以外の場合 → コメントは入れず、**空白行のみ**でフェーズを区切る

```typescript
// ✅ 良い例：シンプルなテスト → 空白行のみでフェーズを区切る
it('returns_user_when_valid_id_is_provided', async () => {
  const event = createApiGatewayEvent({ pathParameters: { id: 'user-123' } })

  const result = await handler(event, context)

  expect(result.statusCode).toBe(200)
  expect(JSON.parse(result.body).name).toBe('Alice')
})

// ✅ 良い例：準備が複数行 → フェーズコメントを入れる
it('returns_order_summary_with_applied_discount', async () => {
  // Arrange
  const user = createUser({ membershipLevel: 'gold' })
  const items = [createItem({ price: 1000 }), createItem({ price: 2000 })]
  const event = createApiGatewayEvent({
    body: JSON.stringify({ userId: user.id, items }),
  })

  // Act
  const result = await handler(event, context)

  // Assert
  const body = JSON.parse(result.body)
  expect(result.statusCode).toBe(200)
  expect(body.totalAmount).toBe(2700)
  expect(body.discountApplied).toBe(true)
})
```

#### テストケースの命名規則

- **非開発者にも検証内容が伝わる名前**にする
- テスト対象の**メソッド名を含めない**（テストはコードではなく振る舞いを検証している）
- `should be` ではなく事実を示す表現（`is`、`returns`、`throws`）を使う
- アンダースコアで単語を区切る

```typescript
// ✅ 良い例：振る舞いが明確、メソッド名を含まない
'returns_400_when_required_parameter_is_missing'
'expired_session_is_rejected'
'discount_is_applied_when_user_is_gold_member'

// ❌ 悪い例：メソッド名を含む
'handleRequest_returns_400_for_invalid_input'

// ❌ 悪い例：should be を使用
'should_be_rejected_when_session_is_expired'

// ❌ 悪い例：検証内容が曖昧
'returns_error_for_invalid_input'  // "invalid" が何を指すか不明確
```

#### SUT（テスト対象）の明示

テスト対象は変数名 `sut` で明示し、テスト対象と依存の区別をわかりやすくする。

```typescript
const sut = handler  // Lambda handlerがテスト対象
const result = await sut(event, context)
```

#### テスト内でif文を使わない

テストケース内にif文がある場合、1つのテストケースで多くのことをしようとしている兆候である。テストケースを分割すること。

#### パラメータ化テスト

- 同じロジックに異なる入力を流し込む場合に使用する
- **正常系と異常系は必ず分離する**

```typescript
// ✅ 良い例：正常系と異常系を分けたパラメータ化テスト
describe('delivery_date_validation', () => {
  // 異常系
  it.each([-1, 0, 1])('past_or_today_date_%d_days_from_now_is_invalid', (days) => {
    const date = addDays(new Date(), days)
    expect(isValidDeliveryDate(date)).toBe(false)
  })

  // 正常系
  it.each([2, 3, 10])('date_%d_days_from_now_is_valid', (days) => {
    const date = addDays(new Date(), days)
    expect(isValidDeliveryDate(date)).toBe(true)
  })
})
```

### 2.6 テストフィクスチャの方針

#### beforeEachでの過度な共通化を避ける

`beforeEach` でテストフィクスチャを共通化すると、テストケース間の結合が強くなり、1つのテストの修正が他のテストに影響するリスクが生じる。

**beforeEachに配置してよいもの：**
- テスト実行に最低限必要な土台（DB接続の初期化、ログ出力の初期化など）

**beforeEachに配置してはならないもの：**
- テストケース固有のデータ・オブジェクトの準備

#### テストデータの共通化パターン

準備フェーズのコード重複を避けるために、以下のパターンを使用する。

| パターン | 用途 | 特徴 |
| --- | --- | --- |
| Object Mother | 典型的なテストデータの生成 | メソッド名でデータの意図が明確 |
| Test Data Builder | 柔軟なカスタマイズが必要な場合 | デフォルト値 + 必要箇所のみ上書き |

```typescript
// Object Motherパターン：ファクトリ関数でデフォルト値を持つテストデータを生成
const createApiGatewayEvent = (overrides?: Partial<APIGatewayProxyEvent>) => ({
  httpMethod: 'GET',
  path: '/',
  headers: {},
  pathParameters: null,
  queryStringParameters: null,
  body: null,
  ...overrides,
})

// 使用例：必要な部分だけ上書き
const event = createApiGatewayEvent({ pathParameters: { id: 'user-123' } })
```

### 2.7 カバレッジの考え方

- カバレッジはテストの質が**悪いことを示せても、良いことを証明できない**
- カバレッジ率の**強要はしない**（100%でなければコミットできない等は不適切）
- カバレッジはあくまで**参考指標**として活用し、未検証の経路を特定してブラックボックステストを追加する材料にする
- assertなしでコードを実行するだけでもカバレッジにカウントされるため、カバレッジの数値だけで品質は判断できない

### 2.8 テスト対象の判断基準

「コードは資産ではなく負債である」の原則に従い、すべてのコードにテストを書くのではなく、**テストによるバグ検出の価値がテストの保守コストを上回る部分**のみをテスト対象とする。

#### テスト対象とするもの

- ビジネスロジック（ドメイン上重要な処理）
- ドメイン上重要な制約の事前条件チェック（ガード句）
- サポートログ（外部向け：いつ・誰が・どの操作をしたか）の出力

<details>
<summary>テスト対象とする理由</summary>

- **ビジネスロジック：** テストの費用対効果が最も高い部分。バグが混入した場合のビジネスへの影響が大きく、テストによる保護の価値が高い
- **事前条件チェック：** データの整合性を守る不変条件の侵害を防ぐ処理であり、壊れた場合の影響範囲が広い
- **サポートログ：** カスタマーサポートや監査など外部から観察されることを意図したログは、アプリケーションの観察可能な振る舞いの一部である
</details>

#### テスト対象としないもの

- privateメソッド・private関数
- 単純な委譲のみのコード
- 診断ログ（開発者向けのデバッグ用ログ）の出力
- ライブラリ内部の挙動

<details>
<summary>テスト対象としない理由</summary>

- **privateメソッド・private関数：** 実装の詳細にあたる。直接テストするとリファクタリング時にテストが壊れ（偽陽性）、リファクタリングへの耐性を損ねる。privateな処理はそれを呼び出すpublicなAPIを通じて間接的に検証されるべきである
- **単純な委譲のみのコード：** テストを書いても検出できるバグがほぼなく、費用対効果が低い
- **診断ログ：** 開発者しか見ないログは実装の詳細であり、外部から観察される振る舞いではない。テスト対象にすると内部構造の変更でテストが壊れる
- **ライブラリ内部の挙動：** サードパーティの責務であり、自プロジェクトのテストで保証すべき範囲ではない
</details>

### 2.9 フロントエンド固有のガイドライン

#### 基本方針

フロントエンドの単体テストも古典学派の原則に従い、**ユーザー操作に対する振る舞い**を検証する。内部の実装詳細（state変数の値、内部メソッドの呼び出し）ではなく、ユーザーが観察できる結果（画面の表示内容、DOM の変化）を検証する。

#### 検証対象

| 対象 | 検証する振る舞い |
| --- | --- |
| コンポーネント | ユーザー操作に対するレンダリング結果 |
| カスタムフック | 入力に対する戻り値・状態変化 |
| ユーティリティ関数 | 入力に対する出力値 |

#### コンポーネントテストの原則

- **ユーザーの視点**でテストする（Testing Libraryの思想に準拠）
- 要素の取得は `getByRole`、`getByText` など**ユーザーが認識できる属性**で行う
- 内部stateやpropsの直接検証はしない

```typescript
// ✅ 良い例：ユーザー視点で振る舞いを検証
it('displays_error_message_when_form_submission_fails', async () => {
  render(<LoginForm />)

  await userEvent.click(screen.getByRole('button', { name: '送信' }))

  expect(screen.getByText('入力内容を確認してください')).toBeInTheDocument()
})

// ❌ 悪い例：実装の詳細（state）を検証
it('sets_error_state_on_submit', () => {
  const { result } = renderHook(() => useLoginForm())
  act(() => result.current.handleSubmit())
  expect(result.current.errorState).toBe(true)  // 内部stateの検証
})
```

## 3. 結合テストの方針

### 3.1 目的

### 3.2 テストフレームワーク

### 3.3 テスト環境

### 3.4 前提条件

- CDKデプロイが完了していること

## 4. 結合テストケース

#### テストケース一覧

| ID       | ケース種別 | テストケース名                 | 確認観点                             |
| -------- | ---------- | ------------------------------ | ------------------------------------ |
| HTTP-001 | 正常系     | トップページ表示               | 静的ファイルが正しく配信されるか     |
| HTTP-002 | 正常系     | 認可エンドポイントリダイレクト | 認可URLが正しく生成されるか          |
| HTTP-003 | 正常系     | 認証成功ページ表示             | コールバックページが配信されるか     |
| HTTP-004 | 正常系     | エラーページ表示               | エラーページが配信されるか           |
| HTTP-005 | 正常系     | OIDCパラメータ検証             | state/nonce/PKCEが正しく設定されるか |

#### テストケース詳細

## 5. テスト実行方法

### 5.1 単体テスト実行

### 5.2 結合テスト実行

## 6. テスト結果記録

### 6.1 テスト実行記録テンプレート

| 項目               | 値         |
| ------------------ | ---------- |
| テスト実行日       | YYYY-MM-DD |
| テスト実行者       |            |
| 環境URL            |            |
| デプロイバージョン |            |
